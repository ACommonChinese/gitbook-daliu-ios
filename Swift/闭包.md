# 闭包

#### 闭包

```Swift
// 无参闭包：
let sayHello = {
    print("hello world!")
}

sayHello()

// 带参的闭包：
let divide = {
    (val1: Int, val2: Int) -> Int in
        return val1 / val2
}
let result = divide(200, 20)
print(result)

// 看一个数组排序的示例：
public func sorted(by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> [Element]

let names = ["A", "D", "C", "B", "G"]

直接使用闭包：
var reversed = names.sorted { (s1: String, s2: String) -> Bool in
    return s1 > s2
}
print(names) // ["A", "D", "C", "B", "G"]
print(reversed) // ["G", "D", "C", "B", "A"]

也可以使用函数：
func backwards(s1: String, s2: String) -> Bool {
    return s1 > s2
}
reversed = names.sorted(by: backwards)
print(reversed) // ["G", "D", "C", "B", "A"]

let names = ["A", "D", "C", "B", "G"]

// 可以使用参数名缩写
var reversed = names.sorted(by: {$0 > $1})
print(reversed)
```

尾随闭包：  
尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用。  
其实尾随闭包只是改了一种写法，即如果闭包是函数的最后一个参数，则调用的时候可以放在函数括号之后

```Swift
func calculate(_ a: Int, _ b: Int, _ sum: (Int, Int) -> Int) -> Int {
    return sum(a, b)
}

// 不使用尾随闭包
var result = calculate(20, 30, { (a: Int, b: Int) -> Int in
    return a + b
})

print(result) // 50

// 使用尾随闭包
result = calculate(2, 3) { (a: Int, b: Int) -> Int in
    return a + b
}

print(result) // 5

再示例：
let names = ["T", "A", "B", "S", "D"]

var reversed = names.sorted() { (a: String, b: String) -> Bool in // 这里()可以省略
    return a > b
}
print(reversed)

reversed = names.sorted(by: {
    (a: String, b: String) -> Bool in
        return a > b
})

print(reversed)

再示例：
// 尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用
func test(closure: (String) -> Void) -> Void {
    closure("hello")
}

// 不使用尾随闭包进行函数调用
test(closure: {(a: String) -> Void in
    print(a)
})

// 使用尾随闭包进行函数调用
test() { (a: String) -> Void in
    print(a)
}

// 使用尾随闭包进行函数调用（省略括号）
test { (a: String) -> Void in
    print(a)
}


let names = ["AT", "AE", "D", "S", "BE"]

// 不使用尾随闭包进行函数调用
var reversed_0 = names.sorted(by: {(v1: String, v2: String) -> Bool in
    return v1 < v2
})
print(reversed_0)

// 使用尾随闭包进行函数调用
var reversed_1 = names.sorted() {
    $0 < $1
}
print(reversed_1)

// 使用尾随闭包进行函数调用（省略括号）
var reversed_2 = names.sorted { (v1: String, v2: String) -> Bool in
    return v1 < v2
}
print(reversed_2)
```

#### 闭包捕获值

```Swift
// 闭包可以在其定义的上下文中捕获常量或变量。
// 即使定义这些常量和变量的原域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。
// Swift最简单的闭包形式是嵌套函数，也就是定义在其他函数的函数体内的函数。
// 嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量。
// 函数和闭包都是引用类型
func makeIncrement(a: Int) -> () -> Int {
    var total = 0
    func incrementor() -> Int {
        total += a
        return total
    }
    return incrementor
}

// incrementor实际上捕获并存储了变量total的一个副本，而该副本随着incrementor一同被存储
// 所以我们调用这个函数时会累加

let incrementByTen = makeIncrement(a: 10)

// 返回的值为10
print(incrementByTen()) // 10

// 返回的值为20
print(incrementByTen()) // 20

// 返回的值为30
print(incrementByTen()) // 30

let block = incrementByTen
print(block()) // 40
```
