# 闭包

#### 闭包

```Swift
// 无参闭包：
let sayHello = {
    print("hello world!")
}

sayHello()

// 带参的闭包：
let divide = {
    (val1: Int, val2: Int) -> Int in
        return val1 / val2
}
let result = divide(200, 20)
print(result)

// 看一个数组排序的示例：
public func sorted(by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> [Element]

let names = ["A", "D", "C", "B", "G"]

直接使用闭包：
var reversed = names.sorted { (s1: String, s2: String) -> Bool in
    return s1 > s2
}
print(names) // ["A", "D", "C", "B", "G"]
print(reversed) // ["G", "D", "C", "B", "A"]

也可以使用函数：
func backwards(s1: String, s2: String) -> Bool {
    return s1 > s2
}
reversed = names.sorted(by: backwards)
print(reversed) // ["G", "D", "C", "B", "A"]

let names = ["A", "D", "C", "B", "G"]

// 可以使用参数名缩写
var reversed = names.sorted(by: {$0 > $1})
print(reversed)
```

### 尾随闭包：  
尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用。  
其实尾随闭包只是改了一种写法，即如果闭包是函数的最后一个参数，则调用的时候可以放在函数括号之后

```Swift
func calculate(_ a: Int, _ b: Int, _ sum: (Int, Int) -> Int) -> Int {
    return sum(a, b)
}

// 不使用尾随闭包
var result = calculate(20, 30, { (a: Int, b: Int) -> Int in
    return a + b
})

print(result) // 50

// 使用尾随闭包
result = calculate(2, 3) { (a: Int, b: Int) -> Int in
    return a + b
}

print(result) // 5

再示例：
let names = ["T", "A", "B", "S", "D"]

var reversed = names.sorted() { (a: String, b: String) -> Bool in // 这里()可以省略
    return a > b
}
print(reversed)

reversed = names.sorted(by: {
    (a: String, b: String) -> Bool in
        return a > b
})

print(reversed)

再示例：
// 尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用
func test(closure: (String) -> Void) -> Void {
    closure("hello")
}

// 不使用尾随闭包进行函数调用
test(closure: {(a: String) -> Void in
    print(a)
})

// 使用尾随闭包进行函数调用
test() { (a: String) -> Void in
    print(a)
}

// 使用尾随闭包进行函数调用（省略括号）
test { (a: String) -> Void in
    print(a)
}

let names = ["AT", "AE", "D", "S", "BE"]

// 不使用尾随闭包进行函数调用
var reversed_0 = names.sorted(by: {(v1: String, v2: String) -> Bool in
    return v1 < v2
})
print(reversed_0)

// 使用尾随闭包进行函数调用
var reversed_1 = names.sorted() {
    $0 < $1
}
print(reversed_1)

// 使用尾随闭包进行函数调用（省略括号）
var reversed_2 = names.sorted { (v1: String, v2: String) -> Bool in
    return v1 < v2
}
print(reversed_2)
```

#### 闭包捕获值

```Swift
// 闭包可以在其定义的上下文中捕获常量或变量。
// 即使定义这些常量和变量的原域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。
// Swift最简单的闭包形式是嵌套函数，也就是定义在其他函数的函数体内的函数。
// 嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量。
// 函数和闭包都是引用类型
func makeIncrement(a: Int) -> () -> Int {
    var total = 0
    func incrementor() -> Int {
        total += a
        return total
    }
    return incrementor
}

// incrementor实际上捕获并存储了变量total的一个副本，而该副本随着incrementor一同被存储
// 所以我们调用这个函数时会累加

let incrementByTen = makeIncrement(a: 10)

// 返回的值为10
print(incrementByTen()) // 10

// 返回的值为20
print(incrementByTen()) // 20

// 返回的值为30
print(incrementByTen()) // 30

let block = incrementByTen
print(block()) // 40
```

### @escaping

参考：[https://www.jianshu.com/p/266c2370effd](https://www.jianshu.com/p/266c2370effd)

@escaping闭包被译为逃逸闭包，如果一个闭包被作为一个参数传递给一个函数，并且在函数return之后才被唤起执行，那么这个闭包是逃逸闭包。简单而言，escaping的闭包就是在函数return后执行的闭包（逃出到函数外执行），noescaping闭包就是在函数内执行的闭包（函数内执行，随函数的终结而终结）。

看一下不逃逸闭包的生命周期：

1. Pass a closure into a function
2. The function runs the closure (or not)
3. The function returns

然后这个closure就死掉了  

Swift3之后，传递给参数的闭包默认是non-escaping闭包，In Swift 3, closure parameters are non-escaping by default; you can use the new @escaping attribute if this isn’t what you want. Non-escaping closures passed in as arguments are guaranteed to not stick around once the function returns.

来看一个示例： 

```swift
public class ViewController : UIViewController {
    /// 声明一个属性作为闭包变量，这个是escaping闭包
    public var success: ((_ vc: ThirdViewController) -> Void)?
    
    public func setSuccess(callback: @escaping ((ThirdViewController) -> Void) {
        // Swift3之后，传递给参数的闭包默认是non-escaping闭包
        // 如果上面没有escaping修饰，编译器报错：Assigning non-escaping parameter 'callback' to an @escaping closure
        self.success = callback
    }
}
```

### 闭包类型typealias

```swift
/// public typealias AnyClass = AnyObject.Type
public typealias MyCallback = (AnyObject?) -> Void
public typealias MyCallback2 = (String, String) -> String
```

### 闭包Copy

闭包Closure在Swift中没有显示Copy的概念。  

参见[Here](https://forums.swift.org/t/copying-a-closure-in-swift/18087)  
The copying mechanism in ObjC is just for getting the block off the stack; once it’s off the stack, “copying” just retains the existing value. That detail is something that Swift hides from you.



